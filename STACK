***************************************************************************
* Program: STACK
* Author : Ian McGowan
* Date   : 06/13/89
* Version: 1.9.8
* Comment: Stacks TCL commands
***************************************************************************
PRINT 'Version 1.9.8'
EQUATE INSERT TO '1',REPLACE TO '-1',BEEP TO CHAR(7)
EQUATE RET TO 13, ESC TO 27, UP.KEY TO 1, DOWN.KEY TO 2
EQUATE PG.UP.KEY TO 21, PG.DOWN.KEY TO 22
EQUATE NUL TO '',SPC TO ' ',TRUE TO 1, FALSE TO 0
EQUATE SEARCH TO '~'
EQUATE UNIX TO '!'
EQUATE BELL TO CHAR(7), OTHERWISE TO 1
TERM=UPCASE(GETENV("TERM"))
IF INDEX(TERM,'WY',1) THEN TERM='W'
CS=@(-1);EOL=@(-4);EOS=@(-3);UP=@(-10)
PROMPT NUL
SEL.LIST.OUT = ""
*
T='/tmp/':@LOGNAME:'.term'
EXECUTE \!tput cols > \:T ;* Always returns 80 if you capture
EXECUTE \!cat \:T CAPTURING TERM.WIDTH
EXECUTE \!rm \:T
TERM.WIDTH=TERM.WIDTH<1>
PRINT 'Term width=':TERM.WIDTH
*
LONG.LINE = 9999;LIST.DET.FLAG=0
EXECUTING = FALSE;SL.ACTIVE = FALSE
SELECT.LIST = NUL;OLD.WORD = NUL
SELECT.STATEMENT=FALSE ; CAP.ACTIVE=FALSE
*
PWD=GETENV("PWD")
I=LEN(PWD) ; ACC=NUL
FOR F=I TO 1 STEP -1
  IF PWD[F,1] = '/' THEN EXIT
  ACC=PWD[F,1]:ACC
NEXT F
*
USERNAME=UPCASE(@LOGNAME)
HOME.DIR=GETENV("HOME")
STACK.ITEM='.STACK_':USERNAME
ALIAS.ITEM='.STACK.ALIAS_':USERNAME
PROGRAM.ITEM='.STACK.PROGRAM_':USERNAME
SETTING.ITEM='.STACK.SETTING_':USERNAME
HOME.FILE='HOME.':UPCASE(USERNAME)
OPEN 'VOC' TO VOC ELSE STOP 201,'VOC'
OPEN '_XML_' TO XML ELSE STOP 201,'_XML_' ;* Exists in every Unidata account
OPEN HOME.FILE TO HOME.F ELSE
  R='DIR' ; R<2>=HOME.DIR ; R<3>='D_VOC'
  WRITE R ON VOC, HOME.FILE
  OPEN HOME.FILE TO HOME.F ELSE STOP 201, HOME.FILE
END
OPEN 'CTLGTB' TO CTLGTB ELSE STOP 201,'CTLGTB'
OPEN 'CTLG'   TO CTLG   ELSE STOP 201,'CTLG'
*
SETTINGS      = ';'        ;* DEFAULT COMMAND SEPERATOR
SETTINGS<2>   = '.'        ;* DEFAULT STACK CHAR
SETTINGS<3>   = '/'        ;* DEFAULT PROG CHAR
SETTINGS<4>   = 9999       ;* DEFAULT MAX # LINES IN STACK
SETTINGS<5>   = '!vi'      ;* DEFAULT SCREEN EDITOR (try !joe :)
SETTINGS<6>   = 'AE'       ;* DEFAULT LINE EDITOR
SETTINGS<7>   ='* Edited :';* DEFAULT HEADER STRING
SETTINGS<8>   = TRUE       ;* DEFAULT USE GET.LINE SUBR
SETTINGS<9>   = 'BP.DEV'   ;* DEFAULT WORK FILE
SETTINGS<10>  = FALSE      ;* DEFAULT = CONVERT TO UCASE
SETTINGS<11>  = ""         ;* DEFAULT STARTUP COMMAND
SETTINGS<12>  = "#R#A>"    ;* DEFAULT PROMPT
SETTINGS<13>  = -2         ;* DEFAULT X DISPLACEMENT FOR PROMPT
SETTINGS<14>  = "bash"     ;* DEFAULT SHELL FOR UNIX COMMANDS
SETTINGS<15>  = ""         ;* DEFAULT PROGRAM STACK TO USE
*
READ R FROM HOME.F, SETTING.ITEM ELSE R=NUL
I=DCOUNT(SETTINGS,@AM)
FOR F=1 TO I
  IF R<F> # NUL THEN SETTINGS<F> = R<F>
NEXT F
COMMAND.SEPERATOR = SETTINGS<1>
STACK.CHAR   = SETTINGS<2>
PROG.CHAR    = SETTINGS<3>
MAX.STACK    = SETTINGS<4>
WP.VERB      = SETTINGS<5>
ED.VERB      = SETTINGS<6>
STAMP.STRING = SETTINGS<7>
GET.LINE.FLAG= SETTINGS<8>
WORK.FILE    = SETTINGS<9>
MCU.ON       = SETTINGS<10>
STARTUP      = SETTINGS<11>
PROMT        = SETTINGS<12>
X.DISP       = SETTINGS<13>
DEF.SHELL    = SETTINGS<14>
STACK.NAME   = SETTINGS<15>
WRITE SETTINGS ON HOME.F, SETTING.ITEM
*
IF STACK.NAME = '' THEN
  PROGRAM.ITEM='.STACK.PROGRAM_':USERNAME
END ELSE
  PROGRAM.ITEM='.STACK.PROGRAM_':USERNAME:'_':STACK.NAME
END
READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
*
EXEC.LINE="!hostname" ; CAP.ACTIVE=TRUE ; GOSUB EXEC.SUB
HOST.NAME=EXEC.CAP<1>
*
READ STACK FROM HOME.F, STACK.ITEM ELSE STACK = NUL
READ ALIASES FROM HOME.F, ALIAS.ITEM ELSE ALIASES = NUL
* Override with my favorites for now.  It's a pain to manage per system.
ALIASES<1>='ACTIVE'
ALIASES<1,2>='CS'
ALIASES<1,3>='L'
ALIASES<2>='SELECT LS.MASTER WITH NUM.OF.ASSETS > "0"'
ALIASES<2,2>='CLEARSELECT'
ALIASES<2,3>='LIST LS.MASTER'
OLD.X.DISP=X.DISP
RTN=NUL
IF STARTUP # NUL THEN ANS=STARTUP ; GOSUB COMMAND ; STARTUP=NUL
ANS=NUL
*
LOOP
  GOSUB EXPAND.PROMPT
  PRINT PROMPT.DISP:
  X = LEN(PROMPT.DISP) + X.DISP
  ENTRY = NUL;LEN = LONG.LINE;DISP.LEN=TERM.WIDTH-1-X
  GOSUB GET.INPUT
  ANS=ENTRY
  * Reread the program and command stack, since they maybe modified
  * in another session
  READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
  READ STACK FROM HOME.F, STACK.ITEM ELSE STACK = NUL
  READ ALIASES FROM HOME.F, ALIAS.ITEM ELSE ALIASES = NUL
  IF RTN # ESC THEN GOSUB COMMAND
REPEAT
*
GET.INPUT:
  IF GET.LINE.FLAG THEN
    *CALL GET.LINE.STACK(X,LEN,DISP.LEN,ENTRY,RTN)
    GOSUB GET.LINE
  END ELSE
    PRINT @(X):;INPUT ENTRY
    RTN = RET
  END
RETURN
*
COMMAND:
  MAX.STACK=DCOUNT(STACK,@AM)
  BEGIN CASE
      * Map up and down arrows to .R1 and .Rn
    CASE RTN = UP.KEY
      ANS = '.R1'
    CASE RTN = PG.UP.KEY
      IF UNASSIGNED(P2) THEN P2 = 20
      IF UNASSIGNED(P1) THEN P1 = 1
      P2 = P2 + 20
      P1 = P1 + 20
      IF P2 > MAX.STACK THEN P2 = MAX.STACK
      IF P1 > MAX.STACK-20 THEN P1 = MAX.STACK-20
      ANS = '.L':P1:',':P2
    CASE RTN = PG.DOWN.KEY
      IF UNASSIGNED(P2) THEN P2 = 20
      IF UNASSIGNED(P1) THEN P1 = 1
      P2 = P2 - 20
      P1 = P1 - 20
      IF P2 < 20 THEN P2=20
      IF P1 < 1 THEN P1=1
      ANS = '.L':P1:',':P2
    CASE ANS='?'
      ANS='.H'
  END CASE
  IF ANS = NUL THEN RETURN
  UNIX.COMMAND=FALSE
  IF ANS[1,1] = UNIX THEN UNIX.COMMAND=TRUE
  OLD.STACK = STACK
  START.WORD.SEARCH = 1
  COMMAND.LIST = ANS
  COMMAND.COUNT = 1
  IF STARTUP#NUL THEN EXECUTING=TRUE ELSE EXECUTING=FALSE
  IF UNIX.COMMAND THEN
    * Don't look for ; for unix commands
    GOSUB DO.COMMAND
  END ELSE
    LOOP
      ANS = FIELD(COMMAND.LIST,COMMAND.SEPERATOR,COMMAND.COUNT)
    UNTIL ANS = NUL DO
      GOSUB DO.COMMAND
      COMMAND.COUNT = COMMAND.COUNT + 1
    REPEAT
  END
  WRITE ALIASES ON HOME.F, ALIAS.ITEM
RETURN
*
DO.COMMAND:
  IF NOT(UNIX.COMMAND) THEN
    IF MCU.ON THEN ANS = TRIM(UPCASE(ANS))
    IF ANS[1,5] # 'ALIAS' THEN GOSUB EXPAND.ALIASES
    GOSUB EXPAND.PROG.CHARS
  END
  IF ANS='!' THEN ANS='!':DEF.SHELL
  LEN.ANS = LEN(ANS)
  SEARCH.FOR=NUL
  SELECT.STATEMENT=FALSE
  CAP.ACTIVE=FALSE
  BEGIN CASE
    CASE ANS[1,1] = STACK.CHAR
      ANS = TRIM(UPCASE(ANS))
      GOSUB STACK.COMMAND
    CASE ANS[1,1] = PROG.CHAR
      ANS = TRIM(UPCASE(ANS))
      GOSUB PROG.COMMAND
    CASE ANS[1,1] = SEARCH
      GOSUB SEARCH.COMMAND
    CASE ANS = 'OFF' OR ANS = 'Q' OR ANS = 'INFO'
      GOSUB WRITE.INFO
      STOP
    CASE ANS[1,5] = 'ALIAS'
      GOSUB DO.ALIAS
    CASE ANS = 'CI'
      * CONTRACT INQUIRY
      DATA 0
      DATA 0
      DATA 0
      DATA 0
      EXECUTE \CMAINT.00\
      GOSUB UPDATE.STACK
    CASE ANS = 'CM'
      * CONTRACT MAINTENANCE
      DATA 1
      DATA 0
      DATA 0
      DATA 0
      EXECUTE \CMAINT.00\
      GOSUB UPDATE.STACK
    CASE ANS = 'CCI'
      * CUSTOMER INQUIRY
      DATA 0
      DATA 0
      DATA 0
      EXECUTE \CDMAINT.00\
      GOSUB UPDATE.STACK
    CASE ANS = 'CCM'
      * CUSTOMER MAINTENANCE
      DATA 1
      DATA 0
      DATA 0
      EXECUTE \CDMAINT.00\
      GOSUB UPDATE.STACK
    CASE ANS = 'TM'
      DATA 1
      DATA 0
      EXECUTE \TMAINT.00\
      GOSUB UPDATE.STACK
    CASE ANS = 'ICONV'
      CONV='I'
      GOSUB CONV
    CASE ANS = 'OCONV'
      CONV='O'
      GOSUB CONV
    CASE FIELD(ANS,SPC,1) = 'PIVOT'
      GOSUB PIVOT
      GOSUB UPDATE.STACK
    CASE FIELD(ANS,SPC,1) = 'DDD'
      GOSUB DDD
      GOSUB UPDATE.STACK
    CASE FIELD(ANS,SPC,1) = 'BPI'
      GOSUB BPI
      GOSUB UPDATE.STACK
    CASE FIELD(ANS,SPC,1) = 'SF'
      GOSUB SEARCH.FILE
      GOSUB UPDATE.STACK
    CASE FIELD(ANS,SPC,1) = 'AF'
      GOSUB ATB.FIND
      GOSUB UPDATE.STACK
    CASE OTHERWISE
      IF NOT(EXECUTING) THEN
        GOSUB UPDATE.STACK
      END
      IF ANS[1,6] = 'SELECT' OR ANS[2,6]= 'SELECT' OR ANS[1,8]= 'GET.LIST' OR ANS[1,6] = 'SEARCH' THEN SELECT.STATEMENT=TRUE
      EXEC.LINE = ANS
      GOSUB EXEC.SUB
  END CASE
RETURN
*
DO.ALIAS:
  AL = FIELD(ANS,SPC,2)
  STRING = NUL;I = 3
  LOOP
    F = FIELD(ANS,SPC,I)
  UNTIL F = NUL DO
    STRING = STRING:SPC:F
    I = I + 1
  REPEAT
  BEGIN CASE
    CASE AL = NUL AND STRING = NUL
      GOSUB LIST.ALIAS
    CASE STRING = NUL
      GOSUB LIST.ONE.ALIAS
    CASE 1
      GOSUB SET.ALIAS
  END CASE
RETURN
*
SET.ALIAS:
  STRING=STRING[2,LONG.LINE]
  PRINT AL:'=':STRING
  LOCATE AL IN ALIASES<1> BY 'AL' SETTING P THEN
    ALIASES<2,P> = STRING
  END ELSE
    INS AL BEFORE ALIASES<1,P>;INS STRING BEFORE ALIASES<2,P>
  END
RETURN
*
LIST.ALIAS:
  I = DCOUNT(ALIASES<1>,@VM)
  FOR F = 1 TO I
    PRINT ALIASES<1,F>,ALIASES<2,F>
  NEXT F
RETURN
*
LIST.ONE.ALIAS:
  LOCATE AL IN ALIASES<1> BY 'AL' SETTING P ELSE PRINT AL:' not found';RETURN
  X=0;LEN=99;DISP.LEN=30;ENTRY=ALIASES<2,P>
  GOSUB GET.INPUT
  IF RTN = 27 THEN RETURN
  ALIASES<2,P> = ENTRY
  IF ENTRY = NUL THEN DEL ALIASES<1,P>;DEL ALIASES<2,P>
RETURN
*
EXEC.SUB:
  IF EXEC.LINE = NUL THEN RETURN
  IF CAP.ACTIVE THEN
    EXECUTE EXEC.LINE CAPTURING EXEC.CAP
  END ELSE
    EXECUTE EXEC.LINE
  END
  IF SYSTEM(11) > 0 THEN SL.ACTIVE = TRUE ELSE SL.ACTIVE = FALSE
RETURN
*
EXPAND.PROG.CHARS:
  * expand //10 to be IV.BP IV.EQP.MNT for example
  POS = 1
  LOOP
    I = INDEX(ANS,PROG.CHAR:PROG.CHAR,POS)
  UNTIL I = 0 DO
    VAR = NUL;IDX = I+2
    LOOP
      C = ANS[IDX,1]
    UNTIL NOT(NUM(C)) OR C = NUL DO
      VAR = VAR:C
      IDX = IDX+1
    REPEAT
    IF NUM(VAR) AND VAR > 0 THEN
      ANS = ANS[1,I-1]:PROGRAMS<VAR>:ANS[IDX,LONG.LINE]
    END ELSE
      POS = POS + 1
    END
  REPEAT
RETURN
*
EXPAND.ALIASES:
  SWAP SPC WITH @VM IN ANS ; POS = 1
  LOOP
    R = ANS<1,POS>
  UNTIL R = NUL DO
    LOCATE R IN ALIASES<1> BY 'AL' SETTING P THEN ANS<1,POS> = ALIASES<2,P>
    POS = POS + 1
  REPEAT
  SWAP @VM WITH SPC IN ANS
RETURN
*
EXPAND.PROMPT:
  IF SL.ACTIVE THEN
    PROMPT.DISP='#RSEL>'
    OLD.X.DISP=X.DISP
    X.DISP=-2
  END ELSE
    PROMPT.DISP = PROMT
    X.DISP=OLD.X.DISP
  END
  CTR = 1
  LOOP
    I = INDEX(PROMPT.DISP,'#',CTR)
  UNTIL I = 0 DO
    F = PROMPT.DISP[I+1,1]
    L = PROMPT.DISP[1,I-1];R = TRIM(PROMPT.DISP[I+2,LONG.LINE])
    BEGIN CASE
      CASE F = 'B'
        PROMPT.DISP = L:CHAR(7):R
      CASE F = 'A'
        PROMPT.DISP = L:ACC:R
      CASE F = 'T'
        PROMPT.DISP = L:OCONV(TIME(),'MTS'):R
      CASE F = 'D'
        PROMPT.DISP = L:OCONV(DATE(),'D'):R
      CASE F = 'E'
        PROMPT.DISP = L:CHAR(ESC):R
      CASE F = 'R'
        PROMPT.DISP = L:CHAR(13):CHAR(10):R
      CASE F = '#'
        PROMPT.DISP = L:'#':R
        CTR = CTR + 1
      CASE F = 'U'
        PROMPT.DISP = L:USERNAME:R
      CASE F = 'H'
        PROMPT.DISP=L:FIELD(HOST.NAME,".",1):R
      CASE OTHERWISE
        CTR = CTR + 1
    END CASE
  REPEAT
RETURN
*
STACK.COMMAND:
  BEGIN CASE
    CASE ANS='.D'
      LIST.DET.FLAG=NOT(LIST.DET.FLAG)
    CASE ANS[1,2] = '.L'
      IF ANS = '.L' THEN ANS = '.L,20'
      GOSUB GET.PARAMS
      IF RANGE.ERROR THEN RETURN
      I = DCOUNT(STACK,@AM)
      IF I = 0 THEN PRINT 'No items present';RETURN
      IF P2 > I THEN P2 = I
      PRINT
      FOR F = P2 TO P1 STEP -1
        IF LIST.DET.FLAG THEN
          PRINT SPC:F'R#3':" ":STACK<F,1>'L#20':' ':OCONV(STACK<F,2>,'D-YMD'):' ':OCONV(STACK<F,3>,'MTS'):' ':STACK<F,4>
        END ELSE
          PRINT SPC:F'R#3':" ":STACK<F,4>
        END
      NEXT F
    CASE ANS[1,2] = '.R' OR ANS[1,2] = '.X'
      IF STACK = NUL THEN PRINT BELL ELSE GO EDIT
    CASE ANS = '.P'
      PRINT '#R - Return  #A - Account  #D - Date  #T - Time #P - Port'
      PRINT '#E - Escape  #L - Level    #U - User  #H - Host'
      PRINT 'Prompt':
      X = 7;DISP.LEN = 60;ENTRY = PROMT;LEN = 99;GOSUB GET.INPUT
      PROMT = ENTRY
      PRINT 'Enter the X displacement for input :':
      ENTRY = NUL;LEN = 5;DISP.LEN = 5;X = 37;GOSUB GET.INPUT
      X.DISP = ENTRY
      IF NOT(NUM(X.DISP)) THEN X.DISP = 0
      SETTINGS<12> = PROMT
      SETTINGS<13> = X.DISP
      OLD.X.DISP=X.DISP
    CASE ANS = '.H'
      PRINT 'TCL STACK COMMANDS--------------------------------------------'
      PRINT 'Ctrl-A      Start of line    Ctrl-R      Toggle insert mode'
      PRINT 'Ctrl-B      Back one char    Ctrl-U      Page Up'
      PRINT 'Ctrl-D      Delete char      Ctrl-V      Page Down'
      PRINT 'Ctrl-E      End of line      Ctrl-W      Delete word'
      PRINT 'Ctrl-F      Forward char     Ctrl-X      Forward word'
      PRINT 'Ctrl-G      Cancel line      Ctrl-Z      Back word'
      PRINT 'Ctrl-I      Forward word     ~xyz        Search for xyz'
      PRINT 'Ctrl-J      Delete to end    .D          Toggle detail off/on'
      PRINT 'Ctrl-L      Clear screen     .Lm,n       List entry m thru n'
      PRINT 'Ctrl-M      Accept line      .Rn         Restore entry n, edit'
      PRINT 'Ctrl-N      Next line        '
      PRINT 'Ctrl-P      Previous line    Q           Quit back to TCL'
      PRINT
      PRINT 'PROGRAM STACK COMMANDS----------------------------------------'
      PRINT '/           List the active program stack'
      PRINT '/LL         List all available program stacks'
      PRINT '/L BLAH     Switch the program stack to BLAH'
      PRINT '/Nx Add a New program        /Fx Format the x`th program'
      PRINT '/Ex Edit the x`th program    /WW Edit the program list'
      PRINT '/Wx VI the x`th program      /S  Sort the program stack'
      PRINT '/Bx Compile the x`th program /BR Compile and run'
      PRINT
      PRINT 'UTILITIES-----------------------------------------------------'
      PRINT 'AF          ATB Finder, search definitions - AF MRKTNG'
      PRINT 'BPI         List table definitions - BPI LS.CTD.PYMTHIST'
      PRINT 'CI/CM/TM    Contract Inquiry/Maintenance/Table Maintenance'
      PRINT 'DDD         Search dictionary definitions - DDD LS.MASTER EQUIP'
      PRINT 'ICONV/OCONV Test format masks/Convert Data'
      PRINT 'PIVOT       Profile data - PIVOT LS.MASTER LESSOR GROSS.CONTRACT'
      PRINT 'SF          Search files and dictionaries - SF DICT LS.MASTER ASSETS'
    CASE ANS = '.U'
      IF MCU.ON THEN MCU.ON = FALSE;PRINT 'upper case off' ELSE MCU.ON = TRUE;PRINT 'UPPER CASE ON'
    CASE OTHERWISE
      PRINT 'There is no such STACK command':BELL
      PRINT '? for help'
  END CASE
RETURN
*
GET.PARAMS:
  I = INDEX(ANS,',',1)
  IF I # 0 THEN
    L = I-1;P1 = NUL
    LOOP
      IF NUM(ANS[L,1]) THEN P1 = ANS[L,1]:P1;L=L-1 ELSE EXIT
    REPEAT
    P2 = ANS[I + 1, LEN.ANS]
  END ELSE
    P1 = NUL
    LOOP
      IF NUM(ANS[LEN.ANS,1]) THEN P1 = ANS[LEN.ANS,1]:P1;LEN.ANS=LEN.ANS-1 ELSE EXIT
    REPEAT
    IF P1 = NUL THEN P1 = 1
    P2 = P1
  END
  IF P1 = NUL THEN P1 = 1
  IF P2 = NUL THEN P2 = MAX.STACK
  IF NUM(P1) & NUM(P2) & P1 > 0 & P2 <= MAX.STACK THEN
    RANGE.ERROR = FALSE
  END ELSE
    RANGE.ERROR = TRUE
    PRINT 'Range Error':BELL
  END
RETURN
*
EDIT:
  * Some of the stuff in here is redundant, repeating COMMAND
  * but to gosub command introduces re-entrancy problems
  * That's why we use the dreaded GOTO command
  N = ANS[3,LEN.ANS]
  IF NOT(NUM(N)) THEN PRINT 'No such line number - ':N:BELL;RETURN
  IF N = NUL THEN N = 1
  LOOP WHILE N # NUL AND STACK<N> # NUL DO
    PRINT UP:N 'R%3':':':EOL:
    ENTRY = STACK<N,4>
    IF ENTRY = "" THEN ENTRY = STACK<N> ;* Legacy stack commands, no timestamp
    X = 5;DISP.LEN = TERM.WIDTH-1-X;LEN = LONG.LINE
    IF ENTRY # NUL THEN
      OLD.ENTRY = ENTRY
      GOSUB GET.INPUT
      ANS = ENTRY
    END
    BEGIN CASE
      CASE RTN = UP.KEY
        IF SEARCH.FOR # NUL THEN
          GO SEARCH.COMMAND
        END ELSE
          N = N + 1
          IF STACK<N> = NUL THEN N = 1
        END
      CASE RTN = DOWN.KEY
        N = N - 1
        IF N = 0 THEN
          N=1; PRINT BELL:
        END
      CASE RTN = RET
        UNIX.COMMAND=FALSE
        IF ANS[1,1] = UNIX THEN UNIX.COMMAND=TRUE
        IF UNIX.COMMAND THEN
          EXECUTING = FALSE
          IF N = 1 AND ENTRY = OLD.ENTRY THEN EXECUTING = TRUE
          GOSUB DO.COMMAND
          N=NUL
        END ELSE
          C.LIST = ANS
          C.COUNT = 1
          LOOP
            ANS = FIELD(C.LIST,COMMAND.SEPERATOR,C.COUNT)
          UNTIL ANS = NUL DO
            EXECUTING = FALSE
            IF N = 1 AND ENTRY = OLD.ENTRY THEN EXECUTING = TRUE
            GOSUB DO.COMMAND
            C.COUNT = C.COUNT + 1
          REPEAT
          N = NUL
        END
      CASE RTN = ESC
        N = NUL
    END CASE
  REPEAT
RETURN
*
SEARCH.COMMAND:
  * Search the stack for a string
  IF SEARCH.FOR = NUL THEN SEARCH.FOR = ANS[2,LONG.LINE]
  FOUND = FALSE
  FOR F = START.WORD.SEARCH TO MAX.STACK UNTIL FOUND OR STACK<F> = NUL
    IF INDEX(STACK<F,4>,SEARCH.FOR,1) # 0 THEN FOUND = TRUE
  NEXT F
  IF FOUND THEN
    START.WORD.SEARCH = F
    ANS = '.R':F-1
    GO EDIT
  END
  PRINT BELL:SEARCH.FOR:' event not found'
RETURN
*
PROG.COMMAND:
  IF ANS = PROG.CHAR OR ANS=PROG.CHAR:PROG.CHAR THEN GO PRINT.PROG.INFO
  GOSUB PARSE.PROG.COM
  ANS=PROG.COM:SPC:B.FILE:SPC:B.ITEM
  *GOSUB UPDATE.STACK
  BEGIN CASE
    CASE PROG.COM = '/WW'
      WRITE PROGRAMS ON HOME.F, PROGRAM.ITEM
      WP.FILE=HOME.FILE
      WP.ITEM=PROGRAM.ITEM
      GOSUB WP.EDIT
      READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
    CASE PROG.COM = '/N'
      GOSUB GET.PROG.NAME
      IF RTN=13 THEN
        PROGRAMS<PROG.NUM> = PROG
        WRITE PROGRAMS ON HOME.F, PROGRAM.ITEM
      END
      IF B.FILE # '' THEN
        OPEN B.FILE TO F THEN
          OPTIONS=''
          READ DUMMY FROM F, B.ITEM ELSE
            PRINT B.ITEM:' not found.  Use standard header? ':
            INPUT YORN
            IF YORN = 'Y' THEN
              HEADER=STR('*',80)
              HEADER<2>='* Program: ':B.ITEM
              HEADER<3>='* Author : ':USERNAME
              HEADER<4>='* Date   : ':OCONV(DATE(),"D-YMD") ;* E.g. 2017-04-20
              HEADER<5>='* Version: 1.0'
              HEADER<6>='* Comment: Do NOT skip the description'
              HEADER<7>=STR('*',80)
              WRITE HEADER ON F, B.ITEM
            END
          END
          CLOSE F
          WP.FILE=B.FILE
          WP.ITEM=B.ITEM
          GOSUB WP.EDIT
        END ELSE
          PRINT B.FILE:' is not a file in this account'
        END
      END
    CASE PROG.COM = '/H'
      OPTIONS='LESS'
      *CALL CVS.LOG(RTN, B.FILE, B.ITEM, OPTIONS)
    CASE PROG.COM = '/L'
      * Load a new program stack
      STACK.NAME=TRIM(OPTIONS)
      IF STACK.NAME = '' THEN
        PROGRAM.ITEM='.STACK.PROGRAM_':USERNAME
      END ELSE
        PROGRAM.ITEM='.STACK.PROGRAM_':USERNAME:'_':STACK.NAME
      END
      READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
      SETTINGS<15>=STACK.NAME
    CASE PROG.COM = '/LL'
      * List the different program stacks
      EXECUTE \SSELECT \:HOME.FILE:\ WITH @ID = ".STACK.PROGRAM]"\
      LOOP
        READNEXT ID ELSE EXIT
        PRINT ID
      REPEAT
    CASE PROG.COM = '/CI'
      * Check it in
      OPTIONS=''
      *CALL CVS.CHECKIN(RTN, B.FILE, B.ITEM, OPTIONS)
    CASE PROG.COM = '/D'
      * CVS Diff
      OPTIONS='SHOW'
      *CALL CVS.DIFF(RTN, B.FILE, B.ITEM, OPTIONS)
    CASE B.FILE[1,1] = '*' OR B.FILE=''
      NULL ;* Don't do anything with 'comment' or blank entries
    CASE PROG.COM = '/BR'
      GOSUB COMPILE
      EXEC.LINE = B.ITEM
      GOSUB EXEC.SUB
    CASE PROG.COM = '/B'
      GOSUB COMPILE
    CASE PROG.COM = '/E' OR PROG.COM = '/W'
      OPEN B.FILE TO F ELSE PRINT 'Cannot open ':B.FILE:BELL;RETURN
      READ R1 FROM F, B.ITEM ELSE R1=NUL
      IF PROG.COM = '/E' THEN
        EXEC.LINE = ED.VERB:SPC:PROG:OPTIONS
        GOSUB EXEC.SUB
      END ELSE
        WP.FILE=B.FILE
        WP.ITEM=B.ITEM
        GOSUB WP.EDIT
      END
      CLOSE F
    CASE PROG.COM = '/F'
      GOSUB BFORMAT
    CASE PROG.COM = '/R'
      OPEN B.FILE TO F ELSE PRINT 'Cannot open ':B.FILE:BELL;RETURN
      READV R FROM F, B.ITEM, 1 ELSE R=NUL
      CLOSE F
      EXEC.LINE = B.ITEM:OPTIONS
      GOSUB EXEC.SUB
    CASE PROG.COM = '/S'
      * A slow sort of the program stack
      READ REC FROM HOME.F, PROGRAM.ITEM ELSE PRINT 'CANNOT READ ':HOME.FILE:' ':PROGRAM.ITEM ; RETURN
      SORT='AL' ; NEW.REC=''
      I=DCOUNT(REC,@AM)
      FOR F=1 TO I
        L=REC<F>
        LOCATE L IN NEW.REC BY SORT SETTING POS ELSE NULL
        INS L BEFORE NEW.REC<POS>
      NEXT F
      WRITE NEW.REC ON HOME.F, PROGRAM.ITEM
    CASE OTHERWISE
      PRINT 'There is no such PROGRAM command':BELL
      PRINT '? for help'
  END CASE
RETURN
*
COMPILE:
  OPTIONS=''
  * Check for global catalog
  READ DUMMY FROM CTLGTB, B.ITEM THEN
    PRINT B.ITEM:' is cataloged globally'
    OPTIONS='G'
  END
  *
  * Check for local catalog
  READ DUMMY FROM CTLG, B.ITEM THEN
    PRINT B.ITEM:' is cataloged locally'
    OPTIONS:='L'
  END
  *
  * Check for direct catalog
  READ DUMMY FROM VOC, B.ITEM THEN
    IF INDEX(DUMMY<2>,'/CTLG/',1)=0 THEN
      PRINT B.ITEM:' is cataloged direct to ':DUMMY<2>
      OPTIONS:='D'
    END
  END
  *
  IF LEN(OPTIONS) > 1 THEN
    PRINT "OPTIONS=":OPTIONS
    PRINT "I do not like green eggs and ham, nor do I like"
    PRINT "programs cataloged twice.  You must fix, Sam"
    RETURN
  END
  *
  LOOP
  UNTIL OPTIONS#'' DO
    PRINT 'Catalog ':B.ITEM:' -- D)irect, L)ocal or G)lobal :':
    INPUT OPTIONS
    OPTIONS=UPCASE(OPTIONS)
    IF OPTIONS = '/' OR OPTIONS='' THEN RETURN
    * Have to enter D, L or G
    IF OPTIONS # 'L' AND OPTIONS # 'G' AND OPTIONS # 'D' THEN OPTIONS=''
  REPEAT
  *
  EXEC.LINE = 'BASIC ':B.FILE:' ':B.ITEM:' -D' ;* -D includes symbol table
  PRINT EXEC.LINE
  GOSUB EXEC.SUB
  *
  BEGIN CASE
    CASE OPTIONS='G'
      EXEC.LINE = 'CATALOG ':B.FILE:' ':B.ITEM:' FORCE'
      PRINT EXEC.LINE
      GOSUB EXEC.SUB
      * Global, so remove direct or local pointers
      READ R FROM VOC, B.ITEM THEN DELETE VOC, B.ITEM
    CASE OPTIONS='L'
      EXEC.LINE = 'CATALOG ':PROG:' LOCAL FORCE'
      PRINT EXEC.LINE
      GOSUB EXEC.SUB
      * Object is in CTLG file, so remove from SOURCE file
      OPEN B.FILE TO F ELSE PRINT 'Cannot open ':B.FILE:BELL;RETURN
      DELETE F, '_':B.ITEM
      CLOSE F
    CASE OPTIONS='D'
      EXEC.LINE = 'CATALOG ':B.FILE:' ':B.ITEM:' DIRECT FORCE'
      PRINT EXEC.LINE
      GOSUB EXEC.SUB
  END CASE
  *
  EXEC.LINE = 'NEWPCODE' ;* This loads a new version of globally cataloged programs
  GOSUB EXEC.SUB
RETURN
*
PARSE.PROG.COM:
  PROG.NUM = NUL
  F = FIELD(ANS,SPC,1);L = LEN(F);I = L
  LOOP
    IF NUM(F[I,1]) THEN PROG.NUM = F[I,1]:PROG.NUM ELSE EXIT
    I = I - 1
  REPEAT
  IF PROG.NUM = NUL THEN PROG.NUM = 1
  OPTIONS = ANS[L+1,LONG.LINE]
  PROG.COM = ANS[1,I]
  PROG = PROGRAMS<PROG.NUM>
  B.FILE = FIELD(PROG,SPC,1)
  B.ITEM = FIELD(PROG,SPC,2)
RETURN
*
GET.PROG.NAME:
  X = 15;DISP.LEN = 50;LEN = LONG.LINE;ENTRY = PROG
  PRINT 'Program Name :':
  GOSUB GET.INPUT
  ANS = UPCASE(ENTRY)
  IF RTN # 13 THEN RETURN
  GOSUB EXPAND.ALIASES
  IF INDEX(ANS,SPC,1) THEN
    B.FILE = FIELD(ANS,SPC,1)
    B.ITEM = FIELD(ANS,SPC,2)
    PROG=ANS
  END ELSE
    IF ANS = NUL THEN
      B.FILE = NUL ; B.ITEM = NUL ;PROG = NUL
    END ELSE
      B.FILE = WORK.FILE ; B.ITEM = ANS ; PROG = B.FILE:SPC:B.ITEM
    END
  END
RETURN
*
PRINT.PROG.INFO:
  I = DCOUNT(PROGRAMS,@AM)
  PRINT
  FOR F = 1 TO I
    IF PROGRAMS<F> # NUL THEN
      CH=' '
      IF ANS=PROG.CHAR:PROG.CHAR THEN
        * We want cvs status as well
        FILE=FIELD(PROGRAMS<F>,' ',1)
        ITEM=FIELD(PROGRAMS<F>,' ',2)
        R=''
        *CALL CVS.STATUS(R,FILE,ITEM,'')
        STATUS=R<1>
        WORK.VER=R<2>
        CVS.VER=R<3>
        BEGIN CASE
          CASE STATUS='UPTODATE'
            CH='  ':WORK.VER'L#9'
          CASE STATUS='MODIFIED'
            CH='> ':WORK.VER'L#4':' ':CVS.VER'L#4'
          CASE 1
            CH='! ':SPACE(9)
        END CASE
      END
      PRINT F 'L#5':CH:' ':PROGRAMS<F>
    END
  NEXT F
RETURN
*
WRITE.INFO:
  WRITE STACK ON HOME.F, STACK.ITEM
  WRITE ALIASES ON HOME.F, ALIAS.ITEM
  WRITE PROGRAMS ON HOME.F, PROGRAM.ITEM
  WRITE SETTINGS ON HOME.F, SETTING.ITEM
RETURN
*
UPDATE.STACK:
  INS ACC:@VM:DATE():@VM:TIME():@VM:ANS BEFORE STACK<1>
  WRITE STACK ON HOME.F, STACK.ITEM
RETURN
*
WP.EDIT:
  * Edit a record using a visual editor (e.g. vi, joe or emacs)
  DICT=0
  IF FIELD(WP.FILE,' ',1)='DICT' THEN WP.FILE=FIELD(WP.FILE,' ',2) ; DICT=1
  READ REC FROM VOC, WP.FILE ELSE PRINT WP.FILE:' - no VOC item' ; RETURN
  IF (REC<1>#'DIR' AND REC<1>#'LD') OR DICT THEN
    * Copy to a temp DIR type and edit there, ignore the race conditions!
    IF DICT THEN WP.FILE='DICT ':WP.FILE
    OPEN WP.FILE TO T ELSE PRINT WP.FILE:' - cannot OPEN' ; RETURN
    READ R FROM T, WP.ITEM ELSE PRINT WP.ITEM:' - not found' ; RETURN
    WRITE R ON XML, WP.ITEM
    WP.PATH='_XML_'
    DIR.TYPE=0
  END ELSE
    WP.PATH=REC<2>
    IF REC<1>='LD' THEN
      IF INDEX(FILE,',',1) THEN
        WP.PATH=REC<2>:FIELD(FILE,',',2)
      END ELSE
        WP.PATH=REC<2>:'/':FIELD(REC<2>,'/',DCOUNT(REC<2>,'/'))
      END
    END
    DIR.TYPE=1
  END
  EXEC.LINE=WP.VERB:' ':WP.PATH:'/':WP.ITEM
  GOSUB EXEC.SUB
  IF NOT(DIR.TYPE) THEN
    * Copy back to original location
    READ R FROM XML, WP.ITEM ELSE R=''
    WRITE R ON T, WP.ITEM
    CLOSE T
  END
RETURN
*
CONV:
  * Handy way to check ICONV/OCONV data
  LOOP
    PRINT 'Enter mask:':
    INPUT MASK
    IF MASK='' OR MASK='/' THEN RETURN
    PRINT 'Enter data:':
    INPUT DTA
    PRINT 'Result:':
    IF CONV='I' THEN PRINT ICONV(DTA,MASK) ELSE PRINT OCONV(DTA,MASK)
  REPEAT
RETURN
*
PIVOT:
  * Profile a field, e.g. PIVOT LS.MASTER LESSOR GROSS.CONTRACT EQUIPMENT.COST
  FILE=FIELD(ANS," ",2) ; ATB =FIELD(ANS," ",3) ; ATB2=FIELD(ANS," ",4) ; ATB3=FIELD(ANS," ",5) ; ATB4=FIELD(ANS," ",6)
  OPEN "DICT ":FILE TO DICT ELSE PRINT "DICT ":FILE:' not a filename' ; RETURN
  READ UREC FROM DICT,"UATB.COUNTER" ELSE
    UREC=\I\;UREC<2>=\"1"\;UREC<4>=\CNTR\;UREC<5>=\8R\;UREC<6>=\S\
    WRITE UREC ON DICT,"UATB.COUNTER"
  END
  CLOSE DICT
  EXEC.LINE = \SORT \:FILE:\ BY \:ATB:\ BREAK-ON \:ATB:\ TOTAL UATB.COUNTER \
  IF ATB2 # "" THEN EXEC.LINE:= \ TOTAL \:ATB2
  IF ATB3 # "" THEN EXEC.LINE:= \ TOTAL \:ATB3
  IF ATB4 # "" THEN EXEC.LINE:= \ TOTAL \:ATB4
  EXEC.LINE:= \ (IDH \
  GOSUB EXEC.SUB
RETURN
*
DDD:
  * List the DICT, e.g DDD AS.MASTER EQUIP
  FILE = FIELD(ANS," ",2)
  SSTR = FIELD(ANS," ",3)
  FIND.STR=""
  IF SSTR # "" THEN FIND.STR = \WITH @ID = "[\:SSTR:\]" \
  EXEC.LINE=\SORT DICT \:FILE:\ @ID F1 F2 BY F1 BY F2 \:FIND.STR:\ USING DICT VOC (I \
  GOSUB EXEC.SUB
RETURN
*
SEARCH.FILE:
  FILE = FIELD(ANS," ",2)
  ICTR=3
  IF FILE='DICT' THEN ICTR+=1 ; FILE='DICT ':FIELD(ANS," ",3)
  OPEN FILE TO FVAR ELSE PRINT FILE:' - not found' ; RETURN
  SSTR = FIELD(ANS," ",ICTR)
  IF SSTR='' THEN PRINT 'Search for:': ; INPUT SSTR
  IF SSTR='' THEN RETURN
  *
  SSTR1=UPCASE(SSTR)
  SSTR2=DOWNCASE(SSTR)
  SSTR3=OCONV(SSTR,"MCT")
  *
  DATA SSTR
  DATA SSTR1
  DATA SSTR2
  DATA SSTR3
  DATA ""
  EXECUTE \ESEARCH \:FILE:\ WITH @ID # "_]" USING DICT VOC\ CAPTURING DUMMY
  *
  CTR=0 ; FOUND.RECS=''
  LOOP
    READNEXT ID ELSE EXIT
    READ REC FROM FVAR, ID THEN
      IDX = INDEX(UPCASE(REC),SSTR1,1)
      IF IDX OR INDEX(UPCASE(ID),SSTR1,1) THEN
        CTR+=1
        FOUND.RECS<1,CTR>=ID
        IDX -= 10 ; IF IDX < 1 THEN IDX=1
        LINE=REC[IDX,45]
        CONVERT @VM TO "]" IN LINE
        CONVERT @AM TO "~" IN LINE
        LINE=OCONV(LINE,"MCP")
        FOUND.RECS<2,CTR>=LINE
      END
    END
  REPEAT
  *
  QUIT = 0 ; CTR=1 ; MAX.ITEMS=DCOUNT(FOUND.RECS<1>,@VM)
  IF MAX.ITEMS=0 THEN PRINT SSTR:' Not found' ; RETURN
  HDR=@(-1):\SEARCHING FOR "\:SSTR1:\,\:SSTR2:\,\:SSTR3:\" IN \:FILE
  PRINT HDR
  LOOP
    PRINT CTR'R#4':' ':FOUND.RECS<1,CTR>'L#25':FOUND.RECS<2,CTR>'L#65'
    CTR+=1
    IF CTR/20=INT(CTR/20) THEN GOSUB SEARCH.FILE.PROMPT
    IF QUIT THEN RETURN
  REPEAT
RETURN
*
SEARCH.FILE.PROMPT:
  PRINT ; PRINT 'B)ack, E)dit #, V)iew #, W)P#, /:':
  INPUT OPTION
  BEGIN CASE
    CASE OPTION='B'
      CTR-=40
      IF CTR<1 THEN CTR=1
    CASE OPTION[1,1]='E'
      EXECUTE ED.VERB:\ \:FILE:\ \:FOUND.RECS<1,OPTION[2,99]>
      CTR-=20
      IF CTR<1 THEN CTR=1
    CASE OPTION[1,1]='W'
      WP.FILE=FILE
      WP.ITEM=FOUND.RECS<1,OPTION[2,99]>
      GOSUB WP.EDIT
      CTR-=20
      IF CTR<1 THEN CTR=1
    CASE OPTION[1,1]='V'
      PRINT CS:
      EXECUTE \CT \:FILE:\ \:FOUND.RECS<1,OPTION[2,99]>
      CTR-=20
      IF CTR<1 THEN CTR=1
      PRINT 'Press ENTER:':
      INPUT AAA
    CASE OPTION # ''
      * ENTER to keep moving forward
      QUIT=1
  END CASE
  PRINT HDR
RETURN
*
BPI:
  OPEN 'DATABASE.FILES,IL' TO IL ELSE STOP 201,'DATABASE.FILES,IL'
  OPEN 'IL.BPI' TO IL.BPI ELSE STOP 201,'IL.BPI'
  BPI=FIELD(ANS,' ',2)
  IF BPI='' THEN PRINT 'Usage: BPI <name of infolease file|name of BPI>' ; RETURN
  * Param 2 can be a BPI or a FILENAME
  READ DUMMY FROM IL.BPI, BPI ELSE
    READV BPI FROM IL, BPI, 14 ELSE PRINT 'Cannot read DATABASE.FILES,IL',BPI ; RETURN
    * Sample: Attached to FLOAT.INCOME bpi.
    N=DCOUNT(BPI,' ')
    BPI=FIELD(BPI,' ',N-1)
    READ DUMMY FROM IL.BPI, BPI ELSE PRINT 'Cannot get BPI name' ; RETURN
  END
  EXECUTE \AE IL.BPI \:BPI
  CLOSE IL
  CLOSE IL.BPI
RETURN
*
BFORMAT:
  STAR  = '*' ; COLON = ':' ; TAB=CHAR(9)
  IND = 0
  *
  * These are all commands that may have ELSE or THEN statements
  * (or blocks) following them
  SPECIAL.CASES = "GET":@AM:"INPUT":@AM:"LOCATE":@AM:"LOCK":@AM:"MATREAD":@AM:"MATREADU":@AM
  SPECIAL.CASES:= "MATWRITE":@AM:"MATWRITEU":@AM:"OPEN":@AM:"PROCREAD":@AM
  SPECIAL.CASES:= "PROCWRITE":@AM:"READ":@AM:"READNEXT":@AM:"READSEQ":@AM:"READT":@AM:"READU":@AM:"READV":@AM
  SPECIAL.CASES:= "READVU":@AM:"REWIND":@AM:"SEEK":@AM:"WEOF":@AM:"WRITESEQ":@AM
  SPECIAL.CASES:= "WRITET"
  *
  DEF.INDENT=2
  FORMATS=":":@VM:"BEGIN":@VM:"CASE":@VM:"ELSE":@VM:"END":@VM:"FOR":@VM
  FORMATS:="IF":@VM:"LOOP":@VM:"NEXT":@VM:"REPEAT":@VM:"RETURN":@VM
  FORMATS:="THEN":@VM:"UNTIL":@VM:"WHILE"
  * THIS.IND is the amount this line will be in or outdented
  FORMATS<2>=0:@VM:0:@VM:-1:@VM:0:@VM:-1:@VM:0:@VM:0:@VM
  FORMATS<2>:=0:@VM:-1:@VM:-1:@VM:-1:@VM:0:@VM:-1:@VM:-1
  * NEXT.IND is the amount that all following lines will be indented
  FORMATS<3>=1:@VM:2:@VM:0:@VM:1:@VM:-1:@VM:1:@VM:1:@VM
  FORMATS<3>:=1:@VM:-1:@VM:-1:@VM:-1:@VM:1:@VM:0:@VM:0
  FORMATS<4>=DEF.INDENT
  *
  OPEN B.FILE TO FI ELSE PRINT 'Cannot open ':B.FILE ; RETURN
  READ REC FROM FI,B.ITEM ELSE PRINT "CANNOT READ ":B.FILE:" ":B.ITEM ; RETURN
  *WRITE REC ON FI,B.NAME:".BAK"
  SWAP CHAR(9) WITH SPACE(DEF.INDENT) IN REC
  *
  I = DCOUNT(REC,@AM)
  IF I < 2 THEN RETURN
  FOR F = 1 TO I
    PRINT STAR:
    L = REC<F> ; NEXT.LINE=REC<F+1>
    GOSUB FORMAT.LINE
    REC<F> = L
  NEXT F
  WRITE REC ON FI,B.ITEM
  PRINT STAR ; PRINT I:" lines of ":B.ITEM:" formatted"
RETURN
*
FORMAT.LINE:
  L=TRIM(L,' ','B')
  CONVERT TAB TO "" IN L
  FIRST.WORD = FIELD(L,SPC,1)
  LEN.FIRST.WORD = LEN(FIRST.WORD)
  LOCATE FIRST.WORD IN SPECIAL.CASES BY 'AL' SETTING SPECIAL ELSE SPECIAL = 0
  NUM.SPACES = COUNT(L,SPC) + 1
  LAST.WORD = FIELD(L,SPC,NUM.SPACES)
  NEXT.TO.LAST.WORD = FIELD(L,SPC,NUM.SPACES-1)
  THIS.IND = 0
  NEXT.IND = 0
  BEGIN CASE
    CASE L=""
      L="*" ;* Makes pasting code around easier with no blank lines
    CASE FIRST.WORD[LEN.FIRST.WORD,1] = COLON OR NUM(FIRST.WORD)
      * A label
      IND = 0
      LOCATE COLON IN FORMATS<1> SETTING POS ELSE POS = 0
      THIS.IND = FORMATS<2,POS>
      NEXT.IND = FORMATS<3,POS>
    CASE FIRST.WORD = "IF"
      LOCATE FIRST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
      IF LAST.WORD = "THEN" THEN
        THIS.IND = FORMATS<2,POS>
        NEXT.IND = FORMATS<3,POS>
      END
    CASE FIRST.WORD = "END"
      SECOND.WORD = FIELD(L,SPC,2)
      IF SECOND.WORD = "ELSE" THEN
        LOCATE "ELSE" IN FORMATS<1> SETTING POS ELSE POS = 0
        THIS.IND = -FORMATS<3,POS>
        NEXT.IND = FORMATS<2,POS>
      END ELSE
        IF SECOND.WORD = "CASE" THEN
          LOCATE "BEGIN" IN FORMATS<1> SETTING POS ELSE POS = 0
          THIS.IND = -FORMATS<3,POS>
          NEXT.IND = -FORMATS<3,POS>
        END ELSE
          LOCATE FIRST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
          THIS.IND = FORMATS<2,POS>
          NEXT.IND = FORMATS<3,POS>
        END
      END
    CASE SPECIAL
      * Find last word - skip until a space
      IF LAST.WORD = "ELSE" OR LAST.WORD = "THEN" THEN
        LOCATE LAST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
        THIS.IND = FORMATS<2,POS>
        NEXT.IND = FORMATS<3,POS>
      END
    CASE FIRST.WORD = "FOR" AND NEXT.TO.LAST.WORD = "NEXT"
      * FOR loop on one line means do nothing
    CASE FIRST.WORD = "RETURN" AND TRIM(NEXT.LINE) # "*"
      * RETURN without a blank line means do nothing
    CASE 1
      LOCATE FIRST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
      IF POS # 0 THEN
        THIS.IND = FORMATS<2,POS>
        NEXT.IND = FORMATS<3,POS>
      END
  END CASE
  L = SPACE((IND+THIS.IND)*DEF.INDENT):L
  *L = STR(TAB,IND+THIS.IND):L ;* In my misguided youth, tabs seemed cool
  IND = IND + NEXT.IND
RETURN
*
GET.LINE:
  * SUBROUTINE GET.LINE(X,LEN,DISP.LEN,XXDATA,RTN)
  * X           = X POS
  * LEN         = MAX ALLOWED LENGTH
  * DISP.LEN    = MAX DISPLAYED LEN
  * XXDATA      = ON INPUT  VARIABLE XXDATA
  *             = ON OUTPUT RETURNED STRING
  * RTN         = SEQ(CHAR PRESSED TO EXIT)
  * -----------------
  * Important globals
  * CP          = Cursor Position, Y coordinate on the screen 0 -> DISP.LEN
  * CH.PTR      = Pointer into string being edited            1 -> LEN
  * POS         = Pointer to first char currently displayed   1 -> LEN
  * ASC.CH      = The numeric value of the key just entered
  *
  ECHO OFF
  XXDATA = ENTRY
  MODE = INSERT ; TEMP.XXDATA = XXDATA
  BASE = @(X) ; MASK = 'L#':DISP.LEN
  PRINT BASE:
  CURR.LEN = LEN(XXDATA)
  GOSUB GO.END
  RTN=''
  *
  LOOP
    PRINT @(X+CP):
    CH=IN()
    ASC.CH = SEQ(CH)
    EXIT.FLAG=FALSE
    BEGIN CASE
      CASE ASC.CH = 1
        GOSUB GO.BEGIN
      CASE ASC.CH = 2
        GOSUB LEFT
      CASE ASC.CH = 4
        GOSUB DEL
      CASE ASC.CH = 5
        GOSUB GO.END
      CASE ASC.CH = 6
        GOSUB RIGHT
      CASE ASC.CH = 8 AND TERM='W'
        GOSUB LEFT
      CASE ASC.CH = 8
        GOSUB BACK
      CASE ASC.CH = 9
        GOSUB FORWARD.WORD
      CASE ASC.CH = 10 AND TERM='W'
        RTN=2
        EXIT.FLAG=TRUE
      CASE ASC.CH = 10
        GOSUB DEL.TO.END
      CASE ASC.CH=11 AND TERM='W'
        RTN=1
        EXIT.FLAG=TRUE
      CASE ASC.CH=12 AND TERM='W'
        GOSUB RIGHT
      CASE ASC.CH = 13
        EXIT.FLAG = TRUE
        RTN=13
      CASE ASC.CH = 14
        RTN=2
        EXIT.FLAG=TRUE
      CASE ASC.CH = 16
        RTN=1
        EXIT.FLAG=TRUE
      CASE ASC.CH = 18
        GOSUB INSRT
      CASE ASC.CH = PG.UP.KEY
        EXIT.FLAG=TRUE
        RTN=PG.UP.KEY
      CASE ASC.CH = PG.DOWN.KEY
        EXIT.FLAG=TRUE
        RTN=PG.DOWN.KEY
      CASE ASC.CH = 23
        GOSUB DELETE.WORD
      CASE ASC.CH = 24
        GOSUB FORWARD.WORD
      CASE ASC.CH = 7 OR ASC.CH = 12
        IF ASC.CH = 12 THEN PRINT @(-1):
        XXDATA = ''
        EXIT.FLAG=TRUE
        RTN=13
      CASE ASC.CH = 26
        GOSUB BACK.WORD
      CASE ASC.CH = 27
        GOSUB ESC.KEY
      CASE ASC.CH < 27
        PRINT @(0):ASC.CH:
      CASE ASC.CH = 127
        GOSUB BACK
      CASE 1
        GOSUB ORD
    END CASE
    CURR.LEN = LEN(XXDATA)
  UNTIL EXIT.FLAG DO
  REPEAT
  IF XXDATA[CURR.LEN,1] = SPC THEN XXDATA = XXDATA[1,CURR.LEN-1]
  ECHO ON ; PRINT BASE:XXDATA MASK
  ENTRY=XXDATA
RETURN
*
ORD:
  * Ordinary key pressed
  IF CH.PTR # LEN+1 THEN
    IF MODE = INSERT THEN
      IF CURR.LEN = LEN THEN
        PRINT BEEP:
        GOTO SKIP1
      END ELSE
        XXDATA = XXDATA[1,CH.PTR-1]:CH:XXDATA[CH.PTR,CURR.LEN]
      END
    END ELSE
      XXDATA = XXDATA[1,CH.PTR-1]:CH:XXDATA[CH.PTR+1,CURR.LEN]
    END
    CH.PTR = CH.PTR + 1
    IF CP # DISP.LEN THEN
      PRINT @(X+CP):CH:
      IF MODE = INSERT THEN
        PRINT XXDATA[CH.PTR,DISP.LEN-CP-1]:
      END
      CP = CP + 1
    END ELSE
      POS = POS + 1
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END ELSE
    PRINT BEEP:
  END
SKIP1:
RETURN
*
RIGHT:
  * There are 3 situations here -
  * 1 We're pressing the right arrow thru existing text       (CH.PTR = CURR.LEN)
  * 2 We've typed text and are at the end when we press right (CH.PTR > CURR.LEN)
  * 3 We're in the middle of text, pressing the right arrow   (CH.PTR < CURR.LEN)
  IF CH.PTR < LEN THEN
    IF CH.PTR > CURR.LEN THEN PRINT BEEP: ; GOTO SKIP2
    IF CH.PTR = CURR.LEN THEN
      * If the last char is not a space make it one
      IF XXDATA[CURR.LEN,1] # SPC THEN
        XXDATA = XXDATA:SPC
        IF CP # DISP.LEN THEN PRINT @(X+CP+1):SPC:
        CURR.LEN = CURR.LEN + 1
      END ELSE
        PRINT BEEP:
        GOTO SKIP2
      END
    END
    CH.PTR = CH.PTR + 1
    IF CP # DISP.LEN THEN
      * We're not at the end of display so just move the cursor
      CP = CP + 1
    END ELSE
      * We are at the end of the display so leave cursor where
      * it is and scroll through line
      POS = POS + 1
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END ELSE
    PRINT BEEP:
  END
SKIP2:
RETURN
*
FORWARD.WORD:
  * Tab key pressed - move forwards a word
  IF CH.PTR >= CURR.LEN THEN
    PRINT BEEP:
  END ELSE
    LOOP
      CH.PTR = CH.PTR + 1
      CP = CP + 1
    UNTIL XXDATA[CH.PTR,1] = SPC OR CH.PTR = CURR.LEN DO
    REPEAT
    IF CH.PTR # CURR.LEN THEN
      LOOP
        CH.PTR = CH.PTR + 1
        CP = CP + 1
      UNTIL XXDATA[CH.PTR,1] # SPC OR CH.PTR = CURR.LEN DO
      REPEAT
    END
    IF CP > DISP.LEN THEN
      CP = DISP.LEN
      POS = CH.PTR - DISP.LEN
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END
RETURN
*
LEFT:
  * If we're not at the start of data, move left
  IF CH.PTR # 1 THEN
    CH.PTR = CH.PTR - 1
    IF CP # 0 THEN
      * We're not at the start of the display so just move the cursor
      CP = CP - 1
    END ELSE
      * We are at the start of the display so leave cursor and scroll
      POS = POS - 1
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END ELSE
    PRINT BEEP:
  END
RETURN
*
DEL:
  * Delete the character at the cursor and redisplay from this point
  XXDATA = XXDATA[1,CH.PTR-1]:XXDATA[CH.PTR+1,CURR.LEN]
  CURR.LEN = CURR.LEN - 1
  PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
RETURN
*
BACK:
  * Backspace key pressed
  IF CH.PTR # 1 THEN
    CH.PTR = CH.PTR - 1
    XXDATA = XXDATA[1,CH.PTR-1]:XXDATA[CH.PTR+1,CURR.LEN]
    CURR.LEN = CURR.LEN - 1
    IF CP # 0 THEN
      CP = CP - 1
    END ELSE
      POS = POS - 1
    END
    PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
  END ELSE
    PRINT BEEP:
  END
RETURN
*
INSRT:
  * Toggle between insert and replace modes
  MODE = -MODE
RETURN
*
ESC.KEY:
  * ESC pressed, or extended key - wyse50 arrow keys
  * Get next char of extended command
  ALLOW = 0
  EXT.KEY=IN()
  EXT = SEQ(EXT.KEY)
  EXT.KEY = OCONV(EXT.KEY,'MCU')
  BEGIN CASE
    CASE EXT.KEY = 'D'
      GOSUB DELETE.WORD
    CASE EXT.KEY = '[' OR EXT.KEY = 'O'
      EXT.KEY=IN()
      BEGIN CASE
        CASE EXT.KEY = 'C'
          GOSUB RIGHT
        CASE EXT.KEY = 'D'
          GOSUB LEFT
        CASE EXT.KEY = 'A'
          RTN=1
          EXIT.FLAG=TRUE
        CASE EXT.KEY = 'B'
          RTN=2
          EXIT.FLAG=TRUE
      END CASE
  END CASE
RETURN ; * From ESC key
*
BACK.WORD:
  * Shift tab pressed - go back a word
  IF CH.PTR = 1 THEN
    PRINT BEEP:
  END ELSE
    * 2 situations - either we're in a word already or
    * we're at the start of a word
    * If in a word - loop to the start of the word
    * otherwise skip spaces, and then move to start of word
    IF XXDATA[CH.PTR-1,1] # SPC THEN
      LOOP
      UNTIL XXDATA[CH.PTR-1,1] = SPC OR CH.PTR = 1 DO
        CH.PTR = CH.PTR - 1
        CP = CP - 1
      REPEAT
    END ELSE
      * Skip spaces
      LOOP
      UNTIL XXDATA[CH.PTR-1,1] # SPC OR CH.PTR = 1 DO
        CH.PTR = CH.PTR - 1
        CP = CP - 1
      REPEAT
      IF CH.PTR > 1 THEN
        * At word end - move to start of word
        LOOP
        UNTIL XXDATA[CH.PTR-1,1] = SPC OR CH.PTR = 1 DO
          CH.PTR = CH.PTR - 1
          CP = CP - 1
        REPEAT
      END
    END
    IF CP < 0 THEN
      CP = 0
      POS = CH.PTR
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END
RETURN
*
DEL.TO.END:
  * Delete from cursor to end of line
  IF CH.PTR = 1 THEN
    XXDATA = ''
    CP = 0
    POS = 1
  END ELSE
    XXDATA = XXDATA[1,CH.PTR-1]
  END
  CURR.LEN = LEN(XXDATA)
  PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
RETURN
*
DELETE.WORD:
  * Delete to space at right of cursor
  IF CH.PTR >= CURR.LEN THEN
    PRINT BEEP:
  END ELSE
    C = CH.PTR
    LOOP
      C = C + 1
    UNTIL XXDATA[C,1] = SPC OR C = CURR.LEN DO
    REPEAT
    XXDATA = XXDATA[1,CH.PTR-1]:XXDATA[C+1,CURR.LEN]
    CURR.LEN = CURR.LEN - C + CH.PTR - 1
    PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
  END
RETURN
*
GO.BEGIN:
  * Go to the start of data and redisplay
  CP = 0
  CH.PTR = 1
  POS = 1
  PRINT BASE:XXDATA MASK:
RETURN
*
GO.END:
  * Move to the end of data and redisplay
  IF XXDATA[CURR.LEN,1] # SPC THEN
    XXDATA = XXDATA:SPC
    CURR.LEN = CURR.LEN + 1
  END
  IF CURR.LEN < DISP.LEN THEN
    CP = CURR.LEN - 1
    POS = 1
  END ELSE
    CP = DISP.LEN - 1
    POS = CURR.LEN - DISP.LEN + 1
  END
  CH.PTR = CURR.LEN
  PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
RETURN
*
ATB.FIND:
  MSK="L#22"
  ATB = FIELD(ANS," ",2)
  OPEN "IL.TB.CHNG.LOG" TO IL.TB.CHNG.LOG ELSE STOP 201,"IL.TB.CHNG.LOG"
  OPEN "IL.CHANGE.LOG.INDEX" TO IL.CHANGE.LOG.INDEX ELSE STOP 201,"IL.CHANGE.LOG.INDEX"
  OPEN "REV.ATB.LOG" TO REV.ATB.LOG ELSE STOP 201,"REV.ATB.LOG"
  OPEN "HELP.TEXT.USA" TO HELP.TEXT.USA ELSE STOP 201,"HELP.TEXT.USA"
  *
  IF ATB="" THEN
    PRINT "ENTER ATB NAME: ": ; INPUT ATB
    IF ATB="" OR ATB="/" THEN RETURN
  END
  *
  READ AREC FROM REV.ATB.LOG,ATB ELSE
    ATBREC="" ; TEST=""
    EXECUTE \SSELECT REV.ATB.LOG = "[\:ATB:\]"\
    CTR=0
    LOOP
      READNEXT ID ELSE EXIT
      CTR+=1
      PRINT CTR "L#4":ID
      ATBREC<CTR>=ID
      IF MOD(CTR,23)=0 THEN PRINT "[ENTER]": ; INPUT TEST
      IF TEST = "/" THEN EXIT
    REPEAT
    PRINT
    PRINT "Enter choice (1-":CTR:"): ": ; INPUT CHOICE
    IF CHOICE="" OR CHOICE="/" THEN RETURN
    ATB=ATBREC<CHOICE>
    IF ATB="" THEN RETURN
    READ AREC FROM REV.ATB.LOG,ATB ELSE PRINT 'Not found' ; RETURN
  END
  *
  MAXV=DCOUNT(AREC<5>,@VM)
  FNAMES=""
  FOR J=1 TO MAXV
    IF AREC<5,J>[1,2] # "BK" THEN
      * EXCLUDE BK.BACKLOG CRAP
      FNAMES:= AREC<5,J>:",":AREC<6,J>:"  "
    END
  NEXT J
  *
  READV CKEY FROM IL.CHANGE.LOG.INDEX,AREC<24>,1 ELSE CKEY=""
  READ CHNG_REC FROM IL.TB.CHNG.LOG,CKEY ELSE CHNG_REC=""
  READ HELP.TEXT FROM HELP.TEXT.USA,ATB ELSE HELP.TEXT= " NOT FOUND"
  CONVERT "~" TO "" IN HELP.TEXT
  DEP=AREC<16>
  CONVERT @VM TO "," IN DEP
  PRINT
  PRINT ATB
  PRINT
  PRINT "IL.BPI" MSK               :AREC<1>
  PRINT "FILE(S)" MSK              :FNAMES
  PRINT "FIELD" MSK                :AREC<2>
  PRINT "CHANGE LOG INDEX" MSK     :AREC<24>
  PRINT "CHANGE LOG KEY" MSK       :CKEY
  PRINT "TYPE" MSK                 :AREC<3>
  PRINT "MASK" MSK                 :AREC<10>
  PRINT "S/MV" MSK                 :AREC<14>
  PRINT "CONTROLLING/DEPENDENT" MSK:AREC<15>
  PRINT "SUB/MASTER FIELDS" MSK    :DEP
  PRINT "CHG DESCRIPTION" MSK      :CHNG_REC<1>
  IF AREC<32> # "" THEN
    PRINT "COMMENTS" MSK           :AREC<32>
    PRINT
  END
  PRINT
  MAXV=DCOUNT(HELP.TEXT<2>,@VM)
  FOR J=1 TO MAXV
    PRINT HELP.TEXT<2,J>
  NEXT J
  PRINT
RETURN
*
